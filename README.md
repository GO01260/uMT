# uMT
uMT - a preemptive, soft real-time (not deterministic) multitasker for the ARDUINO AVR/SAM/SAMD boards

My name is Antonio Pastore (Torino, Italy) and I have been dealing with real-time operating systems since late 80'. Recently I purchased an Arduino starter kit for my young son to let him understand in which area he wants to develop his professional carreer. As a net effect, I got really fond of the environment and I replaced my useless evening in front of the TV with some Arduino programming. As a first "serious" project I decided to port a real-time kernel I developed almost 30 years ago for the Intel 8086 platform to Arduino. The task indeed proved to be a little bit too complex due to the very limited memory resources of the Arduino Uno board I was using so I decided to rewrite it from scratch with the specific objective to make as tiny as possible to fit in the Arduino Uno. I then purchased a Mega2560 in which uMT can nicely run thanks the 8KB RAM availability. Recently I also purchased a Arduino Due (SAM based) board and I ported uMT also on this board (although the exercize has proven to be quite challenging...). An Arduino Zero (SAMD based) port has been very recently completed as well but NOT tested (unfortunately I do not own a Zero board).


In the uMT library one can find a Getting Started document describing how to use uMT and a Reference Manual describing the uMT calls/primitives. The Arduino library also contains a large set of working examples to show how to use the uMT functionalities.

This is an initial version of uMT and, as such, no extensive testing has been performed. As a consequence, users are warned about the potential instability of the uMT software.

The current version runs, full functionalities, on the Arduino Uno, Mega2560 and Due (and likely on the Zero board as well). A quite comprehensive set of EXAMPLES is provided as well.


Please note that this an EDUCATIONAL tool, not designed for industrial or state-of-the-art application (nor life or mission critical application!!!) and not fully optimized.

Bugs, questions and suggestions can be sent to the author at "go01260@alice.it"

Enjoy!!!


===================================================================================================================

MAIN FUNCTIONALITIES

uMT offers a rich programming environment with over 30 calls:

•	Task management: creation and deletion of independent, priority based tasks with a start-up parameter. Moreover, preemption and timesharing can be enabled/disabled at run time.

•	Semaphore management: counting semaphores with optional timeout (in the simplest form they can be used as mutual exclusion guards).

•	Event management: a configurable number of events per task (16 or 32 events depending on the AVR/SAM architecture) can be used for inter task synchronization, with optional timeout and ALL/ANY optional logic (number of events can be extended to 32/64 by reconfiguration of uMT source code).

•	Timers management: task's timers (timeouts) and agent timers (Event generation in future time) are available.

•	Support Functionalities: system tick, fatal error, rebooting, etc.

•	Interupt Service Routine support. Please read the Getting Started manual for additional information.

===================================================================================================================

ISR MANAGEMENT PERFORMANCE

The “Test30_InterruptLatency.cpp” test has been designed to measure interrupt latency when using direct interrupt handler (no uMT) and using uMT Events (isr_ and isr_p_ calls).

Times are in microseconds.

==============================================================================

Board type=Uno

Measurement Type=micros()

No uMT=8/12

isr_Ev_Send()=64

isr_p_Ev_Send()=20/24

==============================================================================

Board type=Mega2560

Measurement Type=micros()

No uMT=12/16

isr_Ev_Send()=68

isr_p_Ev_Send()=24/28

==============================================================================

Board type=Due

Measurement Type=micros()

No uMT=4

isr_Ev_Send()=22

isr_p_Ev_Send()=20

==============================================================================

Board type=Due

Measurement Type=SysTick->VAL

No uMT=2

isr_Ev_Send()=21

isr_p_Ev_Send()=18

==============================================================================


On AVR boards, the interrupt is generated by setting high a Port (PIN) every second. Note that on AVR boards, micros() has a resolution of 4 microseconds. On Due board, a timer is used to generate periodic interrupts.

Please note that this is a best case scenario when not very many interrupts are executing at the same time. For SAM/SAMD boards, the pendSVHook interrupt is set to the lowest level so a task switching will occur only when all pending interrupts have been serviced.
As a final consideration, direct interrupt handling is significantly faster than using interrupts  + uMT Event management. It is then the trade-off between exceptional performance (direct) and high-performance with rich functionalities (uMT) which might drive the final decision about which one to use.

==============================================================================
